#Сортируемый массив разбивается на две части примерно одинакового размера;
#Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
#Два упорядоченных массива половинного размера соединяются в один.
#1.1. — 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).

#3.1. Соединение двух упорядоченных массивов в один.
#Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере. Пусть мы имеем два уже отсортированных по возрастанию подмассива. Тогда:
#3.2. Слияние двух подмассивов в третий результирующий массив.
#На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
#3.3. «Прицепление» остатка.
#Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.
a = [5, 2, 6, 8, 5, 8, 1]

def merge_sort(sort):
    if len(sort) < 2:
        return sort
    mid = len(sort) // 2
    sort_left = sort[:mid]
    sort_right = sort[mid:]
    merge_sort(sort_left)
    merge_sort(sort_right)
    
    i = 0
    j = 0
    n = 0

    while i < len(sort_left) and j < len(sort_right):
        if sort_left[i] < sort_right[j]:
            sort[n] = sort_left[i]
            i = i + 1
        else:
            sort[n] = sort_right[j]
            j = j + 1
        n = n + 1
    while i < len(sort_left):
        sort[n] = sort_left[i]
        i = i + 1
        n = n + 1
    while j < len(sort_right):
        sort[n] = sort_right[j]
        j = j + 1
        n = n + 1

merge_sort(a)
print(a)