#Сортируемый массив разбивается на две части примерно одинакового размера;
#Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
#Два упорядоченных массива половинного размера соединяются в один.
#1.1. — 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).

#3.1. Соединение двух упорядоченных массивов в один.
#Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере. Пусть мы имеем два уже отсортированных по возрастанию подмассива. Тогда:
#3.2. Слияние двух подмассивов в третий результирующий массив.
#На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
#3.3. «Прицепление» остатка.
#Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.
a = [110, 604, 905, 310, 659, 229, 527, 113, 645, 798, 243, 584, 904, 553, 178, 510, 184, 368, 116, 469, 955, 795, 549, 703, 32, 63, 935, 258, 732, 870, 197, 730, 128, 14, 523, 503, 531, 545, 362, 925, 488, 806, 477, 285, 39, 148, 71, 572, 713, 78, 725, 173, 894, 84, 554, 194, 890, 448, 166, 135, 783, 587, 521, 583, 36, 348, 666, 375, 615, 867, 321, 927, 778, 45, 638, 720, 512, 359, 94, 755, 832, 585, 982, 185, 857, 336, 592, 239, 320, 53, 995, 916, 390, 465, 992, 387, 325, 880, 780, 277]

def merge_sort(sort):
    if len(sort) < 2:
        return sort
    mid = len(sort) // 2
    sort_left = sort[:mid]
    sort_right = sort[mid:]
    merge_sort(sort_left)
    merge_sort(sort_right)

    i = 0
    j = 0
    n = 0

    while i < len(sort_left) and j < len(sort_right):
        if sort_left[i] < sort_right[j]:
            sort[n] = sort_left[i]
            i = i + 1
        else:
            sort[n] = sort_right[j]
            j = j + 1
        n = n + 1
    while i < len(sort_left):
        sort[n] = sort_left[i]
        i = i + 1
        n = n + 1
    while j < len(sort_right):
        sort[n] = sort_right[j]
        j = j + 1
        n = n + 1
b = a.copy()
merge_sort(a)
print(a)
print(b)